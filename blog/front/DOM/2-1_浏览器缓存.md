---
difficulty: easy
type: organize
---

# 浏览器缓存

前后端都有缓存的概念：个人理解缓存是一种快速访问常用资源的机制。比如将常用数据/类实例放在内存中缓存（redis），将常用数据单独存在快速查找表中，将互联网资源放在客户端本地缓存（浏览器），将远端服务器数据放在较近的服务器上（CDN）。

前端有哪些缓存/类缓存机制呢？CDN 快速资源访问，`localStorage`/`sessionStorage` 存储常用数据，以及最经典的浏览器缓存。

## 浏览器缓存基础

无论哪种缓存机制，都涉及到一个经典技术手段：空间换时间。浏览器缓存的本质是将常用资源存在浏览器本地，当浏览器下次尝试访问相同的资源时，会优先判断本地缓存是否可用。浏览器缓存分为两种：
- 强缓存：直接从本地缓存中获取资源。设置方式为在 HTTP 响应头中的 `Expires` 或 `Cache-Control` 字段控制是否缓存，缓存时间等。
  - `Expires`: 源自 HTTP/1.0，设置一个指定过期时间，例如:
    ```http
    Expires: Wed, 21 Oct 2024 07:28:00 GMT
    ```
    由于时间戳存在跨区域，客户端/服务端时间不准确等原因，这个字典基本废弃了
  - `CacheControl`: 源自 HTTP/1.1，包含多个可配置字段，常用的有:
    - `max-age=<seconds>`: 最常用，表示经过多长时间缓存过期，单位为秒
    - `no-cache`: 表示资源在使用前必须重新验证，不能直接使用
    - `no-store`: 表示资源不应该被缓存
    完整的配置字段参考：[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)，一个例子如下:
    ```http
    Cache-Control: max-age=3600, must-revalidate
    ```
- 协商缓存：强缓存失败后，使用协商缓存，可以利用服务端返回资源的请求头中的 `ETag`, `Last-Modified` 等字段判断是否重新下载和解析资源：
  - `ETag`: 一个字符串，用于唯一标识资源
  - `Last-Modified`: 上次修改该资源的时间  
  
  前端发送的请求头中如果有 `If-Modified-Since` 字段，则会根据这两个时间判断资源是否被修改过，没有则使用协商缓存。

## 强缓存

有一种请求无法使用强缓存：通过浏览器 url 地址发送的 Get 请求。

由于强缓存完全由客户端控制，不会经服务端处理，因此他只会根据方面的因素判断是否使用本地资源：
- 强缓存字段：一般是能是缓存时间
- 文件名称

这就会出现一种情形，服务端将文件改了，但是前端仍然使用旧的本地资源。这是最常见的场景。一般我们让客户使用无痕模式，或者F12关闭缓存可以解决这个问题。

现在有很多方案解决这个问题，核心是使用唯一标识的资源明，例如在文件名后生成一个唯一id/加一个hash码，总之保证访问的资源名不同即可。

但有些文件名称是改不了的，例如 `index.html`，此时就不能使用强缓存了。

## 协商缓存

协商缓存因为加入了服务端的判断逻辑，可以更动态与准确地确定某个文件是否使用缓存资源。例如上述的 `index.html` 就可以通过上次修改时间或者 `ETag` 进行判断。

但是，协商缓存需要和后端一起配置，如果后端不支持 `ETag` 逻辑判断，那么这个值就没有效果。

最后借用掘金的一张图总结前端缓存逻辑:

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57afe218c664ef9b92ede954c646e5d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp">

> [强烈推荐看下这篇文章：意外惊喜！浏览器缓存优化方案，让页面加载速度飙升48.5%！](https://juejin.cn/post/7220270978521333797?searchId=202408190102314B8C90D609D072DB12AC)
