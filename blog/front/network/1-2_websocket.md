---
difficulty: easy
type: organize
---

# websocket

## websocket 由来

websocket 是为了解决 http 协议服务端无法主动向客户端传输请求的问题。由于 http 协议是基于 tcp 协议，而 tcp 协议支持双向全双工通信。因此，理论上 tcp 可以实现服务端主动推送信息。除此之外，websocket 还有如下特征：
- 数据格式比较轻量，性能开销小，通信高效。
- 没有同源限制，客户端可以与任意服务器通信。
- 可以发送文本或者二进制

## http 轮询与长轮询

在 http/1.1 时代，通信只能由客户端发起，不具备服务器推送能力。在即使通讯，多人协作等场景下，服务端变动不能即使告知客户端，只能等待客户端发送给对应的请求后才能反馈信息。为了解决这类问题，诞生了几种技术方案。
- 轮询：如果知道某个数据会时常变化，那么只需要频繁调用对应的接口更新数据就可以了，因此写一个 `setInterval` 频繁调用接口就可以。但这存在很多问题
  - http/1.1 不支持多路复用，因此频繁发送 http 请求非常消耗通信资源。即使 http/2.0 支持多路复用，这种做法也太浪费通信资源了。
  - 更新存在间隔：既然是客户端轮询，那么就存在轮询间隔这个时间差，想想现在的多人协作软件，需要等到 1-2s 才能看到同事的鼠标移动，可能你操作完发现同时也操作了同一个地方。
  - 服务端压力：维持来自每个客户端大量不同的轮询请求。
- 长轮询：发一个请求到服务端，让服务端持有一定长的时间，如果这段时间内有数据变化，返回。否则一直等到最长持有时间，告知客户端没有问题。这样减少了 http 请求。但也有问题：
  - 服务端压力大：维护多个不同客户端的请求

值得讨论的是，http/2.0 是支持双向全双工通信的，也支持服务端主动通讯，但为啥不用呢，我觉得有几下原因：
- 有了 websocket 并且很完善（废话）
- http/2.0 的服务端通讯主要是向浏览器返回可能需要的一些静态资源资源文件，例如请求一个 index.html 将对应的 css 和 js 文件也返回
- 没有完善的客户端处理接口，http/2.0 服务端主动推送的对象主要是浏览器而不是开发者。

## 建立 websocket

websocket 和 http 协议同级，都是应用层协议。在 http 协议建立（三次握手）之后，客户端发送一条带有 websocket 标识的 http 数据到服务端，服务端通过 http 返回数据，客户端接收成功之后就用 websocket 协议进行通信了。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7096a51d21e4ec590c0ef5aac273412~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp">

## 实操 websocket

代码中可以通过如下方式创建一个 websocket 对象:

```ts
const ws = new WebSocket("ws://localhost:80");
```

传入服务端地址，注意使用 `ws` 开头表示建立 `websocket` 连接。

`WebSocket` 对象包含很多方法，最常用的是一些事件监听方法，例如:
- `onclose`: 通信中断的回调，对应 `close` 方法。
- `onerror`: 通信错误的回调。
- `onmessage`: 来消息的回调。
- `onopen`: 建立通信的回调。

`WebSocket` 对象也可以主动发送消息到客户端，使用 `send` 方法。

## 断线重连

由于 websocket 支持服务端主动推送的原因，它存在一个大问题：客户/服务端寄了怎么办，两者之一离线了，另一方还在一直发送请求，非常浪费。

常用的解决方案是心跳检测：
- 客户端每隔一段事件发送一个探测包（ping）给服务端
- 客户端启用一个超时定时器
- 服务端接收到检测包，回应一个（pong）包
- 客户端收到，重制超时定时器，说明服务器正常。
- 没收到，说明服务端寄了

本质上是一个轮询检测，不过 websocket 数据体积小，性能开销更小。